# 객체

자료형 챕터에서 배웠듯이 자바스크립트엔 여덟 가지 자료형이 있습니다. 
이 중 일곱 개는 오직 하나의 데이터(문자열, 숫자 등)만 담을 수 있어 '원시형(primitive type)'이라 부릅니다.

객체형은 원시형과 달리 다양한 데이터를 담을 수 있습니다.
키로 구분된 데이터 집합이나 복잡한 객체를 저장할 수 있음
객체는 자바스크립트 거의 모든 면에 녹아있는 개념이므로 자스를 잘 다루려면 객체를 잘 이해하고 있어야합니다.

객체는 중괄호 `{...}` 를 이용해 만들 수 있다.
중괄호 안에는 키(key): 값(value) 쌍으로 구성된 프로퍼티를 여러 개 넣을 수 있는데, 키엔 문자형, 값엔 모든 자료형이 허용된다.
프로퍼티 키는 프로퍼티 이름이라고도 부른다.


서랍장을 상상하면 객체를 이해하기 쉽다. 서랍장 안 파일은 프로퍼티, 각각에 붙어있는 이름표는 객체의 키라고 생각하면 된다.
복잡한 서랍장 안에서 이름표를 보고 원하는 파일을 쉽게 찾을 수 있듯이, 객체에선 키를 이용해 프로퍼티를 쉽게 찾을 수 있다.
추가나 삭제도 마찬가지다.

빈 객체(서랍장)을 만드는 방법은 두 가지가 있다.

```
let user = new Object(); // 객체 생성자 문법
let user = {}; 객체 리터럴 문법
```

중괄호를 이용해 객체를 선언한느 것은 객체 리터럴이라고 부름.
객체를 선언할 때느 주로 이 방법을 사용함.

## 리터럴과 프로퍼티

중괄호 안에는 키:값 쌍으로 구성된 프로퍼티가 들어감

```
let user = {
     name: "예린",
     age: 40
     
};;
```

콜론 : 을 기준으로 왼쪽엔 키가, 오른쪽엔 값이 위치함. 프로퍼티 키는 프로퍼티 이름 혹은 식별자라고 부름.

객체 user 에는 프로퍼티가 두 개 있음.

1. 첫 번쨰  프로퍼티 - "name" 이름과 "예린" 값
2. 두 번째 프로퍼티 - "age" 이름과 40 값

서랍장(객체 user) 안에 파일 두 개(프로퍼티 두 개)가 담겨있는데, 각 파일에 “name”, "age"라는 이름표가 붙어있다고 생각하시면 쉽다.


서랍장에 파일을 추가하고 뺄 수 있듯이 개발자는 프로퍼티를 추가, 삭제할 수 있습니다.

점 표기법(dot notation)을 이용하면 프로퍼티 값을 읽는 것도 가능함.


```
alert( user.name ); // John
alert( user.age ); // 30
```


```
user.isAdmin = true;
```

delete 연산자를 사용하면 프로퍼티를 삭제할 수 있다.

delete user.age;

여러 단어를 조합해 프로퍼티 이름을 만든 경우엔 프로퍼티 이름을 따옴표로 묶어줘야 한다.

```
let user = {
  name: "John",
  age: 30,
  "likes birds": true  // 복수의 단어는 따옴표로 묶어야 합니다.
};

```

마지막 프로퍼티 끝은 쉼표로 끝날 수 있다.

```
let user = {
  name: "John",
  age: 30,
}
```

이런 쉼표를 ‘trailing(길게 늘어지는)’ 혹은 ‘hanging(매달리는)’ 쉼표라고 부른다. 이렇게 끝에 쉼표를 붙이면 모든 프로퍼티가 유사한 형태를 보이기 때문에 프로퍼티를 추가, 삭제, 이동하는 게 쉬워진다.

```
상수 객체는 수정될 수 있습니다.
주의하세요. const로 선언된 객체는 수정될 수 있습니다.
````


```
const user = {
  name: "John"
};

user.name = "Pete"; // (*)

alert(user.name); // Pete
```

```
(*)로 표시한 줄에서 오류를 일으키는 것처럼 보일 수 있지만 그렇지 않습니다. const는 user의 값을 고정하지만, 그 내용은 고정하지 않습니다.

const는 user=...를 전체적으로 설정하려고 할 때만 오류가 발생합니다.

상수 객체 프로퍼티를 만드는 또 다른 방법이 있습니다. 
```


## 대괄호 표기법

여러 단어를 조합해 프로퍼티 키를 만든 경우엔, 점 표기법을 사용해 프로퍼티 값을 읽을 수 없다.


```
// 문법 에러가 발생합니다.
user.likes birds = true
```

자바스크립트는 위와 같은 코드를 이해하지 못합니다. user.likes까지는 이해하다가 예상치 못한 birds를 만나면 문법 에러를 뱉어냅니다.

점은 키가 유효한 변수 식별자인 경우에만 사용할 수 있다.
유효한 변수 식별자에는 공백이 없어야한다.
또한 숫자로 시작하지 않아야하고
특수문자가 없어야한다

키가 유효한 변수 식별자가  아닌 경우엔 점 표기법 대신에
대괄호 표기법이라 불리는 방법을 사용할 수 있다.
대괄호 표기법은 키에 어떤 문자열 이있던지 상관없이 동작한다.

```
let user = {};;

// set
user["like birds"] = true;

// get
alert(user["나는 새가 좋아"]); //true

// delete
delete user["나는 새가 좋아"]; 

```

이제 문법 에러가 안 발생함. 대괄호 표기법 안에서 문자열을 사용할 땐 문자열을 따옴표로 묶어줘야함. 따옴표의 종류는 상관없음.

대괄호 표기법을 사용하면 아래 예시에서 변수를 키로 사용한 것과 같이 문자열 뿐만아니라 모든 표현식의 평가결과를 프로퍼티 키로 사용할 수 있음.


```
let key = "likes birds";

// user["likes birds"] = true; 와 같습니다.
user[key] = true;
```

변수 key는 런타임에 평가되기 때문에 사용자 입력값 변경 등에 따라 값이 변경될 수 있습니다. 어떤 경우든, 평가가 끝난 이후의 결과가 프로퍼티 키로 사용됩니다. 이를 응용하면 코드를 유연하게 작성할 수 있습니다.


```
let user = {
  name: "John",
  age: 30
};

let key = prompt("사용자의 어떤 정보를 얻고 싶으신가요?", "name");

// 변수로 접근
alert( user[key] ); // John (프롬프트 창에 "name"을 입력한 경우)
```

그런데 점 표기법은 이런 방식이 불가함.

```
let user = {
  name: "John",
  age: 30
};

let key = "name";
alert( user.key ) // undefined
```

## 계산된 프로퍼티

객체를 만들 때 객체 리터럴 안의 프로퍼티 키가 대괄호로 둘러싸여있는 경우 이를 계산된 프로퍼티라고 부른다.


```
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.
};

alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력됩니다.
```

<!-- 이 부분이 좀 이해가 안 가네... -->

위 예시에서 [fruit]는 프로퍼티 이름을 변수 fruit에서 가져오겠다는 것을 의미함.

사용자가 프롬포트  대화상자에 apple을 입력했다면 bag엔 {apple:5} 가 할당됨..
아래 예시는 위 예시와 동일하게 동작함.

```
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
let bag = {};

// 변수 fruit을 사용해 프로퍼티 이름을 만들었다.
bag[fruit] = 5
```

두 방식 중 계산된 프로퍼티를 사용한 예시가 더 깔끔해 보임
한편, 다음 예시처럼 대괄호 안에는 복잡한 표현식이 올수도 있음.

```
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```

대괄호 표기법은 프로퍼티 이름과 값으 제약을 없애주기 때문에 점 표기법보다 훨씬 강력함. 근데 작성하기 어렵다는 번거로운 단점이 있음.

이런 이유로 프로퍼티 이름이 확정된 상황이고, 단순한 이름이라면 처음엔 점 표기법을 사용하다가 뭔가 복잡한 상황이 발생했을 때 대괄호 표기법으로 바꾸는 경우가 많음.

## 단축 프로퍼티

실무에서 프로퍼티 값을 기존 변수에서 받아와 사용하는 경우가 종종있음.


```
function makeUser(name, age) {
  return {
    name: name,
    age: age,
    // ...등등
  };
}

let user = makeUser("John", 30);
alert(user.name); // John
```

위 예시의 프로퍼티들은 이름과 값이 변수의 이름과 동일하네요. 이렇게 변수를 사용해 프로퍼티를 만드는 경우는 아주 흔한데, 프로퍼티 값 단축 구문(property value shorthand) 을 사용하면 코드를 짧게 줄일 수 있습니다.

```
function makeUser(name, age) {
  return {
    name, // name: name 과 같음
    age,  // age: age 와 같음
    // ...
  };
}
```
한 객체에서 일반 프로퍼티와 단축 프로퍼티를 함께 사용하는 것도 가능합니다.

```
let user = {
  name,  // name: name 과 같음
  age: 30
};
```

## 프로퍼티 이름의 제약사항

아시다시피 변수 이름(키)엔 ‘for’, ‘let’, ‘return’ 같은 예약어를 사용하면 안됩니다.

그런데 객체 프로퍼티엔 이런 제약이 없습니다.

```
// 예약어를 키로 사용해도 괜찮습니다.
let obj = {
  for: 1,
  let: 2,
  return: 3
};

alert( obj.for + obj.let + obj.return );  // 6

```

이와 같이 프로퍼티 이름엔 특별한 제약이 없습니다. 어떤 문자형, 심볼형 값도 프로퍼티 키가 될 수 있죠(식별자로 쓰이는 심볼형에 대해선 뒤에서 다룰 예정입니다).

문자형이나 심볼형에 속하지 않은 값은 문자열로 자동 형 변환됩니다.

예시를 살펴봅시다. 키에 숫자 0을 넣으면 문자열 "0"으로 자동변환됩니다.

```
let obj = {
  0: "test" // "0": "test"와 동일합니다.
};

// 숫자 0은 문자열 "0"으로 변환되기 때문에 두 얼럿 창은 같은 프로퍼티에 접근합니다,
alert( obj["0"] ); // test
alert( obj[0] ); // test (동일한 프로퍼티)
```

이와 같이 객체 프로퍼티 키에 쓸 수 있는 문자열엔 제약이 없지만,역사적인 이유 때문에 특별 대우를 받는 이름이 하나 있다.
바로, `__proto__` 입니다.

```
let obj ={};
obj.__proto__ = 5; // 숫자를 할당함.
alert(obj.__proto__); // [object object] - 숫자를 할당했지만 값은 객체가 되었습니다. 의도한대로 동작하지 않네요.
```

원시값 5를 할당했는데 무시됐다.
__proto__의 본질은 나중에 배운다.

## `in` 연산자로 프로퍼티 존재 여부 확인하기

자바스크립트 객체의 중요한 특징 중 하나는 다른 언어와는 달리, 존재하지 않는 프로퍼티에 접근하려 해도 에러가 발생하지 않고 undefined를 반환한다는 것입니다.

이런 특징을 응용하면 프로퍼티 존재 여부를 쉽게 확인할 수 있습니다.

```
let user = {};

alert( user.noSuchProperty === undefined ); // true는 '프로퍼티가 존재하지 않음'을 의미합니다.
```
이렇게 undefined와 비교하는 것 이외에도 연산자 in을 사용하면 프로퍼티 존재 여부를 확인할 수 있습니다.

문법은 다음과 같습니다.

```
"key" in object
```


```
let user = { name: "John", age: 30 };

alert( "age" in user ); // user.age가 존재하므로 true가 출력됩니다.
alert( "blabla" in user ); // user.blabla는 존재하지 않기 때문에 false가 출력됩니다.
```

in 왼쪽엔 반드시 프로퍼티 이름이 와야 합니다. 프로퍼티 이름은 보통 따옴표로 감싼 문자열입니다.

따옴표를 생략하면 아래 예시와 같이 엉뚱한 변수가 조사 대상이 됩니다.


```
let user = { age: 30 };

let key = "age";
alert( key in user ); // true, 변수 key에 저장된 값("age")을 사용해 프로퍼티 존재 여부를 확인합니다.
```

왜 굳이 in 연산자가 있는거지? undefined랑 비교하면 되잖아?
이런 의문이 들 수 있다. 
대부분의 경우, 일치 연산자를 사용해서 프로퍼티 존재 여부를 알아내는 방법("=== undefined")은 꽤 잘 동작합니다. 그런데 가끔은 이 방법이 실패할 때도 있습니다. 이럴 때 in을 사용하면 프로퍼티 존재 여부를 제대로 판별할 수 있습니다.

프로퍼티는 존재하는데, 값에 undefined를 할당한 예시를 살펴봅시다.

```
let obj = {
  test: undefined
};

alert( obj.test ); // 값이 `undefined`이므로, 얼럿 창엔 undefined가 출력됩니다. 그런데 프로퍼티 test는 존재합니다.

alert( "test" in obj ); // `in`을 사용하면 프로퍼티 유무를 제대로 확인할 수 있습니다(true가 출력됨).
```


obj.test는 실제 존재하는 실제 존재하는 프로퍼티임.따라서 in 연산자는 정상적으로  true를 반환함.


## ‘for…in’ 반복문

for..in 반복문을 사용하면 객체의 모든 키를 순회할 수 있습니다. for..in은 앞서 학습했던 for(;;) 반복문과는 완전히 다름.

```
for (key in object){
    // 각 프로퍼티 키 (key)를 이용해 본문을 실행함
}

```

```
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};

for(let key in user){
    // 키
  alert( key );  // name, age, isAdmin
  // 키에 해당하는 값
  alert( user[key] ); // John, 30, true
}
```

for..in 반복문에서도 for(;;)반복문 처럼 반복 변수를 선언해줬다는 점에 주목해라

반복 변수명은 자유롭게 설정가능. 'for (let prop in obj)'같이 key 말고 다른 변수명을 사용해도 괜찮습니다.


## 객체 정렬 방식


객체와 객체 프로퍼티를 다루다 보면 "프로퍼티엔 순서가 있을까?"라는 의문이 생기기 마련입니다. 반복문은 프로퍼티를 추가한 순서대로 실행될지, 그리고 이 순서는 항상 동일할지 궁금해지죠.

답은 간단함. 객체는 특별한 방식으로 정렬됨. 정수 프로퍼티는 자동을 ㅗ정렬되고, 그외는 객체에 추가한 순서 그대로 정렬됨.


```
let codes = {
  "49": "독일",
  "41": "스위스",
  "44": "영국",
  // ..,
  "1": "미국"
};

for (let code in codes) {
  alert(code); // 1, 41, 44, 49
}

```
현재 개발 중인 애플리케이션의 주 사용자가 독일인이라고 가정해 봅시다. 나라 번호를 선택하는 화면에서 49가 맨 앞에 오도록 하는 게 좋을 겁니다.

그런데 코드를 실행해 보면 예상과는 전혀 다른 결과가 출력됩니다.

미국(1)이 첫 번째로 출력됩니다.
그 뒤로 스위스(41), 영국(44), 독일(49)이 차례대로 출력됩니다.
이유는 나라 번호(키)가 정수이어서 1, 41, 44, 49 순으로 프로퍼티가 자동 정렬되었기 때문입니다.


```
수 프로퍼티? 그게 뭔가요?
'정수 프로퍼티’라는 용어는 변형 없이 정수에서 왔다 갔다 할 수 있는 문자열을 의미합니다.

문자열 "49"는 정수로 변환하거나 변환한 정수를 다시 문자열로 바꿔도 변형이 없기 때문에 정수 프로퍼티입니다. 하지만 '+49’와 '1.2’는 정수 프로퍼티가 아닙니다.

```

```
// 함수 Math.trunc는 소수점 아래를 버리고 숫자의 정수부만 반환합니다.
alert( String(Math.trunc(Number("49"))) ); // '49'가 출력됩니다. 기존에 입력한 값과 같으므로 정수 프로퍼티입니다.
alert( String(Math.trunc(Number("+49"))) ); // '49'가 출력됩니다. 기존에 입력한 값(+49)과 다르므로 정수 프로퍼티가 아닙니다.
alert( String(Math.trunc(Number("1.2"))) ); // '1'이 출력됩니다. 기존에 입력한 값(1.2)과 다르므로 정수 프로퍼티가 아닙니다.
```

한편 키가 정수가 아닌 경우엔 작성된 순서대로 프로퍼티가 나열됨


```
let user = {
  name: "John",
  surname: "Smith"
};
user.age = 25; // 프로퍼티를 하나 추가합니다.

// 정수 프로퍼티가 아닌 프로퍼티는 추가된 순서대로 나열됩니다.
for (let prop in user) {
  alert( prop ); // name, surname, age
}
```
